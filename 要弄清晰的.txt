【要探索的原理】
反射 class Class.forName()是静态成员 依靠运行时信息来发现该对象和类的真实信息 反射是为了获取class而非反射本身生成对象
jdk动态代理 要加强的是方法 不仅仅是要生成一个对象instance这么简单，生成的是字节码class就相当于是运行期间动态生成和初始化一样的类，如果是生成instance并没有起到加强的作用【测试】
可以写进去也可以不写进去


aop - 系统路径下的功能增强横切，https://www.cnblogs.com/joy99/p/10941543.html，原理
spi - 加载的是第三方框架内容，不是系统路径下的，框架功能扩展
spring spi
spring自动配置
spring起步依赖


META-INF下各文件的意义
META-INF/spring.handlers
META-INF/spring.schemas
META-INF/spring.factories


mybatis本身
mybatis与spring集成
MyBatis集成Spring后，Spring侵入了Mybatis的初始化和mapper绑定，具体就是：
1）Cofiguration的实例化是读取Spring的配置文件（注解、配置文件），而不是mybatis-config.xml
2）mapper对象是方法级别的，Spring通过FactoryBean巧妙地解决了这个问题
3）事务交由Spring管理
https://blog.csdn.net/D_19901719576/article/details/98373254


原生jdbc HikariDataSource
@Mapper注解和@Repository注解
@Mapper的不用加扫描
@Repository需要
@MapperScan再探讨


